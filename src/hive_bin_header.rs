use std::convert::TryInto;
use std::mem;
use nom::{
    IResult,
    bytes::complete::tag,
    number::complete::{le_u32, le_u64}
};
use chrono::{DateTime, Utc};
use serde::Serialize;
use crate::state::State;
use crate::util;

#[derive(Clone, Debug, Eq, PartialEq, Serialize)]
pub struct HiveBinHeader {
    /// The absolute offset of the hive bin, calculated at parse time
    pub file_offset_absolute: usize,
    /// The offset of the hive bin, Value in bytes and relative from the start of the hive bin data
    pub offset_from_first_hbin: u32,
    /// Size of the hive bin
    pub size: u32,
    /// 0 most of the time, can contain remnant data
    pub unknown1: u32,
    /// 0 most of the time, can contain remnant data
    pub unknown2: u32,
    /// Only the first hive bin contains a valid FILETIME. The timestamp in the header of the first hive bin acts as a backup copy of a Last written timestamp in the base block.
    pub timestamp: DateTime<Utc>,
    /// The Spare field is used when shifting hive bins and cells in memory. In Windows 2000, the same field is called MemAlloc, it is used to track memory allocations for hive bins.
    pub spare: u32,
}

impl HiveBinHeader {
    pub(crate) fn from_bytes<'a>(state: &State, input: &'a[u8]) -> IResult<&'a[u8], Self> {
        let file_offset_absolute = state.get_file_offset(input);
        let (input, _signature) = tag("hbin")(input)?;
        let (input, offset_from_first_hbin) = le_u32(input)?;
        let (input, size) = le_u32(input)?;
        let (input, unknown1) = le_u32(input)?;
        let (input, unknown2) = le_u32(input)?;
        let (input, timestamp) = le_u64(input)?;
        let (input, spare) = le_u32(input)?;

        let hbh = HiveBinHeader {
            file_offset_absolute,
            offset_from_first_hbin,
            size,
            unknown1,
            unknown2,
            timestamp: util::get_date_time_from_filetime(timestamp),
            spare
        };

        Ok((
            input,
            hbh
        ))
    }

    pub fn calculate_checksum(bytes: &[u8]) -> u32 {
        let mut index = 0;
        let mut xsum = 0;

        let slice_to_u32 = |s: &[u8]| -> [u8; 4] { s.try_into().expect("slice with incorrect length") };
        let size_of_u32 = mem::size_of::<u32>();

        while index <= 0x01FB {
            xsum ^= u32::from_le_bytes(slice_to_u32(&bytes[index..index + size_of_u32]));
            index += size_of_u32;
        }
        match xsum {
            0 => 1,
            0xFFFFFFFF => 0xFFFFFFFE,
            _ => xsum
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculate_checksum() {
        let bytes = [0x72, 0x65, 0x67, 0x66, 0xd8, 0x00, 0x00, 0x00, 0xd8, 0x00, 0x00, 0x00, 0xa2, 0x18, 0x01, 0x35, 0x47, 0x9f, 0xce, 0x01, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x30, 0x71, 0x00, 0x01, 0x00, 0x00, 0x00, 0x53, 0x00, 0x59, 0x00, 0x53, 0x00, 0x54, 0x00, 0x45, 0x00, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9d, 0xae, 0x86, 0x7e, 0xae, 0xe3, 0x11, 0x80, 0xba, 0x00, 0x26, 0xb9, 0x56, 0xc9, 0x68, 0x00, 0x9d, 0xae, 0x86, 0x7e, 0xae, 0xe3, 0x11, 0x80, 0xba, 0x00, 0x26, 0xb9, 0x56, 0xc9, 0x68, 0x01, 0x00, 0x00, 0x00, 0x01, 0x9d, 0xae, 0x86, 0x7e, 0xae, 0xe3, 0x11, 0x80, 0xba, 0x00, 0x26, 0xb9, 0x56, 0xc9, 0x68, 0x72, 0x6d, 0x74, 0x6d, 0xf9, 0x49, 0xdb, 0x2b, 0x1a, 0xe3, 0xd0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0xca, 0x62, 0xcc, 0x00];
        assert_eq!(0xCC62_CA20, HiveBinHeader::calculate_checksum(&bytes));
    }

    #[test]
    fn test_parse_hive_bin_header() {
        let state = State::from_path("test_data/NTUSER.DAT", 4096).unwrap();
        let ret = HiveBinHeader::from_bytes(&state, &state.file_buffer[4096..4128]);

        let expected_output = HiveBinHeader {
            file_offset_absolute: 4096,
            offset_from_first_hbin: 0,
            size: 4096,
            unknown1: 0,
            unknown2: 0,
            timestamp: util::get_date_time_from_filetime(129782121007374460),
            spare: 0
        };

        let remaining: [u8; 0] = [0; 0];
        let expected = Ok((&remaining[..], expected_output));

        assert_eq!(
            expected,
            ret
        );
    }
}
